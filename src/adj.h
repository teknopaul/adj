#ifndef _LIBADJ_INCLUDED_
#define _LIBADJ_INCLUDED_

#include <stdio.h>
#include <stdlib.h>
#include <alsa/asoundlib.h>
#include <cdj/vdj.h>

//SNIP_adjh_constants
#define ADJ_PPQ                 96    // ticks per quarter note
#define ADJ_CLOCKS_PER_BEAT     24    // clock signals required per beat (defined by midi spec)
#define ADJ_BEATS_QUEUED        0.25  // we queue up clock signals on the sequencer, and so loop less often
#define ADJ_MAX_CLIENT_LEN      2048  // max length of USB/ASLA midi clients (not sure if this is too large or if tis unlimited)
#define ADJ_TICK0               0
#define ADJ_MIN_BPM             60
#define ADJ_MAX_BPM             240
#define ADJ_BEATS_PER_BAR       4     // used by quantized restart, you can stil beat sync other time signatures
//SNIP_adjh_constants

// ui callbacks
typedef void (*adj_message_handler_pt)(char* message);
typedef void (*adj_data_change_handler_pt)(int item, char* data);
typedef void (*adj_tick_handler_pt)(snd_seq_tick_time_t tick);
typedef void (*adj_stop_handler_pt)();
typedef void (*adj_start_handler_pt)();
typedef void (*adj_exit_handler_pt)();

typedef struct {
    char*       seq_name;
    int         client_id;
    snd_seq_t*  alsa_seq;
    int         alsa_port;
    int         q;
    float       bpm;
    snd_seq_tick_time_t tick;
    char        alsa_sync;
    vdj_t*      vdj;
    adj_message_handler_pt      message_handler;
    adj_data_change_handler_pt  data_change_handler;
    adj_tick_handler_pt         tick_handler;
    adj_stop_handler_pt         stop_handler;
    adj_start_handler_pt        start_handler;
    adj_exit_handler_pt         exit_handler;
} adj_seq_info_t;

//SNIP_adjh_constants
#define ADJ_OK                  0  // return code for succes
#define ADJ_ERR                 1  // general error
#define ADJ_ALSA                2  // error generated by alsa api calls
#define ADJ_ALSA_SEQ_OPEN       3
#define ADJ_ALSA_PORT_OPEN      4
#define ADJ_ALSA_QUEUE_ALLOC    5
#define ADJ_RTFM                6  // code error
#define ADJ_ALLOC               7  // pthread generated the error
#define ADJ_THREAD              8  // pthread generated the error
#define ADJ_SYNTAX              9  // syntax error e.g. mmap files
#define ADJ_IO                 10  // i/o error e.g mmap files

#define ADJ_ITEM_PORT       0x01
#define ADJ_ITEM_CLIENT_ID  0x02
#define ADJ_ITEM_MIDI_IN    0x03
#define ADJ_ITEM_MIDI_OUT   0x04
#define ADJ_ITEM_KEYB       0x05
#define ADJ_ITEM_STATE_SEQ  0x06  // from adj_running
#define ADJ_ITEM_STATE_Q    0x07  // running or stopped
#define ADJ_ITEM_BPM        0x08
#define ADJ_ITEM_EVENTS     0x09
#define ADJ_ITEM_OP         0x0A

//SNIP_adjh_constants


// start public api

adj_seq_info_t* adj_calloc();

void adj_free(adj_seq_info_t* adj);

/**
 * Initialise alsa port, sequencer queue and fetches client_id.
 * This must be called before other methods that accept adj_seq_info_t.
 * return value must be validated to be ADJ_OK.
 * THis method is not thread safe and should be called before starting threads that have access to adj_seq_info_t.
 */
int adj_init_alsa(adj_seq_info_t* adj);

/**
 * Start the queue, nothing happens until adj_start() is called.
 */
int adj_init(adj_seq_info_t* adj);

/**
 * Can be used to beat-mix midi, the queue is skewed forwards or backwards for one beat.
 * N.B. this is done with midi, so there is no time stretching or pitch adjusting performed which makes mixing subtly different.
 */
void adj_nudge(adj_seq_info_t* adj, int multiplier);

/**
 * Start the queue again from midi tick 0, this should only be called after adj_stop()
 */ 
void adj_start(adj_seq_info_t* adj);

/**
 * Stop the queue, e.g. with the spacebar.
 */
void adj_stop(adj_seq_info_t* adj);

/**
 * Toggles start or stop state.
 */
void adj_toggle(adj_seq_info_t* adj);

/**
 * Waits for the end of the bar then does stop/start. this enables correcting the phrase when the beats are already in sync
 */
void adj_quantized_restart(adj_seq_info_t* adj);

/**
 * Exit the main loop, this is not immediate.
 */
int adj_exit(adj_seq_info_t* adj);

/**
 * Quit when you dont have a handle on adj_seq_info_t
 * returns true if adj seq was running
 */
int adj_quit();

/**
 * returns non-zero if the adj_init() has been called (and handled correctly) and not adj_exit().
 */
unsigned _Atomic adj_is_running();

/**
 * returns non-zero if adj_stop() was called (and handled correctly)
 */
unsigned _Atomic adj_is_paused();

/**
 * Change the tempo, N.B. not pitch change, or time-strech, for midi this is speed change.
 */
void adj_adjust_tempo(adj_seq_info_t* adj, float bpm_diff);
/**
 * Sets the tempo of a running queue.
 * to set the bpm edit the value of adj->bpm before calling init
 */
void adj_set_tempo(adj_seq_info_t* adj, float bpm);

// end public api

// start util api

unsigned int adj_bpm_to_micros(float bpm);

struct timespec adj_one_beat_time(float bpm);

/**
 * sleep current thread for the duration of one beat
 */
void adj_one_beat_sleep(float bpm);

// end util api


#endif // _LIBADJ_INCLUDED_